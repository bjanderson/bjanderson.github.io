---
title: Creating NPM Packages
category: NPM
description: How to create and deploy your own npm packages.
date: 4/14/2019
hidden: false
---

<div class="blog-post">

  <div class="blog-post-image">
    <img src="./blog-post-image.jpg" alt="Blog Post Image">
    <div class="attribution">
      <a target="_blank"
        href="https://unsplash.com/@vtrsnts?utm_medium=referral&amp;utm_campaign=photographer-credit&amp;utm_content=creditBadge">
        VÃ­tor Santos | Unsplash.com
      </a>
    </div>
  </div>

  <div class="content">

    <h1>Creating NPM Packages</h1>

    <p>
      If you want to build reusable code for the front-end then you need to learn how to build and deploy npm packages.
      You can either choose to use the public npm repository or your own private npm repo, but one thing is certain - if you're doing JavaScript development, then npm is going to be involved in the process somewhere.
    </p>

    <p>
      Like everything else we developers do, once you get the hang of it, it's actually a very easy process.
      And the more you do it, the more opportunities you will find for automating things.
      But we must walk before we run...
    </p>

    <p>
      For our first npm package we will make a simple utils library.
      Before we get into the code, we need to decide where the npm package is going to live.
      Will it be available to the public?
      Is it proprietary and need to be protected?
      Or, are you just learning and experimenting?
    </p>

    <p>
      I'll walk you through my process as an example, and that should give you enough information so that you can figure out how to do things your way.
    </p>

    <p>
      I ultimately intend for my utils library to be public, open-source software.
      However, I want to experiment a bit and climb the learning curve before I try pushing anything out to the community.
      So, I'll start by setting up a private npm repo on my computer, and then, when I'm sure my package is ready for prime-time, I'll move it to it's permanent home in the public npm repo.
    </p>

    <h2>Local/Private Repository</h2>

    <h3>Verdaccio</h3>

    <p>
      First I'm going to install an application named Verdaccio (<a href="https://github.com/verdaccio/verdaccio" target="_blank">https://github.com/verdaccio/verdaccio</a>).
    </p>

    <p>
      You can use Verdaccio as a private repo that your whole team can use, or you can install it on your own machine and use it as a sandbox environment.
      Either way, there's really not much difference in how you use it compared to how you use other private or public npm repos.
    </p>

    <p class="step">
      We install Verdaccio through npm:
      <pre><code class="language-bash">
        npm i -g verdaccio
      </code></pre>
    </p>

    <p class="step">
      And we run Verdaccio as an npm application:
      <pre><code class="language-bash">
        verdaccio
      </code></pre>

      You can also check out the <a href="https://verdaccio.org/docs/en/cli" target="_blank">docs</a> for more cli options.
    </p>

    <p class="step">
      Just like any other npm repository, you need to add a user to Verdaccio before you can publish anything:
      <pre><code class="language-bash">
        npm adduser --registry http://localhost:4873
      </code></pre>

      It will prompt you for a username and password.
      If you use Verdaccio as a private repo for your company's proprietary code, then I would suggest setting up a dedicated account to administer it, otherwise you probably just want to make this easy to remember.
    </p>

    <p class="step">
      Publish a package to your Verdaccio repo:
      <pre><code class="language-bash">
        npm publish --registry http://localhost:4873
      </code></pre>

      If you want to make sure that your package does not get published to the public npm repo, I recommend adding the <code class="language-bash">publishConfig</code> setting to your <code class="language-bash">package.json</code> file, like so:
      <pre><code class="language-text">
        ##########
        # package.json
        ##########

        "publishConfig": { "registry": "http://localhost:4873/" }
      </code></pre>

      Note: If you set <code class="language-bash">"private": true</code> in your <code class="language-bash">package.json</code> file then your package won't be deployed anywhere, so make sure to use the <code class="language-bash">publishConfig</code> setting if you're creating a package that you want to publish to your private repo.
    </p>

    <p>
      Also worth noting here is the need to keep your package versions updated.
      If you try to publish your package with a version number that already exists in your npm repo, the publish command will fail.
      Thankfully, npm provides a <a href="https://docs.npmjs.com/cli/version.html" target="_blank">cli command</a> for updating your package version for you, but you can also edit the version number directly in your <code class="language-bash">package.json</code> file if you wish.
    </p>

    <p class="step">
      And finally, to install a package from your Verdaccio repo you run it like any other npm install command, but you need to include the registry parameter:
      <pre><code class="language-bash">
        npm install my-package --registry http://localhost:4873
      </code></pre>

    </p>

    <p class="step">
      Or you can create a <code class="language-bash">.npmrc</code> file in your project and put the registry setting in it, then you won't have to use the registry flag when you install your package.
      <pre><code class="language-text">
        ##########
        # .npmrc
        ##########

        registry=http://localhost:4873
      </code></pre>
      But, whenever you try to run npm commands in your project, make sure that verdaccio is running or you may get errors saying that your packages can't be found.
    </p>

    <p class="step">
      You can also set the registry setting in your global .npmrc file by running:
      <pre><code class="language-bash">
        npm set registry http://localhost:4873/
      </code></pre>

      This will make any npm install command on your machine look for your Verdaccio repo, though, so you will have to make sure that Verdaccio is always running.
    </p>

    <h3>Errors</h3>

    <p>
      I've run into errors when I start a new project that depends on a shared library from my company's private npm repo where <code class="language-bash">npm install</code> fails with strange permissions errors.
      Unfortunately the error messages can sometimes be unhelpful or even misleading.
      If you get permissions errors when starting a new project and you are using a private npm repo, make sure you are logged in to the npm repo by running:
      <pre><code class="language-bash">
        npm login
      </code></pre>
    </p>

    <p>
      If you don't have login permissions, you may need to exclude your private dependencies from the initial install, and comment out the registry setting in your <code class="language-bash">.npmrc</code> file, install everything from the public npm repo first, and then try installing your private packages again after everything else succeeds.
    </p>

    <h2>Public Repository</h2>

    <p>
      All of these commands work exactly the same for the public npm repo, except that you don't have to set the registry setting anywhere.
      Commands such as <code class="language-bash">npm install</code> and <code class="language-bash">npm publish</code> all point to the public <a href="https://www.npmjs.com/" target="_blank">npmjs.com</a> repo by default.
    </p>

    <h2>Create And Deploy Packages</h2>

    <p>
      OK.
      With all of that out of the way, now we can get in to actually creating the package.
    </p>

    <p>
      First you need some code to publish.
      You don't need much, a single file, with a single function in it would suffice for the purposes of this tutorial.
      Instead of copy and pasting a bunch of code here for use as an example, I'm just going to point you to a project that I already have published, and then explain how I did that in detail.
      So, take a look at my project called <a href="https://github.com/bjanderson/lernato-common" target="_blank">lernato-common</a> on github.
      I used TypeScript to create it, but you can easily ignore the TypeScript bits and focus on the JavaScript aspect if you want to.
      They are similar enough that it should not be a hindrance.
    </p>

    <p>
      The first thing I want to point out is how the source code is being exported.
      If you open the <code class="language-text">src</code> folder and look at the <code class="language-text">index.ts</code> file, you will see that I am simply exporting everything from the other folders.
      And in each of those folders there's another <code class="language-text">index.ts</code> file where I am simply exporting everything from their respective files.
      So, the main package file (<code class="language-text">src/index.ts</code>) is just a place where all of the public facing api of the library is exposed.
    </p>

    <p>
      With that in mind, I will assume that you have some sort of build process in place whether it be via TypeScript, Webpack, Gulp, or whatever.
      And I will assume that the final output of your build process will be placed in a folder named <code class="language-text">dist/</code>.
      If these assumptions are wrong, then you will need to adjust my advice from here forward to match your actual environment.
    </p>

    <p>
      I'm making that point because your <code class="language-text">package.json</code> file is going to point to that one file that exports all of your content.
      In your <code class="language-text">package.json</code> enter a field called <code class="language-text">"main"</code> and point it to your <code class="language-text">dist/index.js</code> file.
      Doing this will allow you to import everything into other projects from the top level of your package.
      If you don't do this, then you will have to path your way down into your package to find your imports.
    </p>

    <p>
      It's also worth noting here that if you are using TypeScript, there is another field you can put in your <code class="language-text">package.json</code> file to point to your type definitions.
      The field is called <code class="language-text">"types"</code> and it needs to point to your <code class="language-text">dist/index.d.ts</code> file.
    </p>

    <p>
      And the next critical piece of the npm package puzzle is a field named <code class="language-text">"files"</code>.
      This is an array of the file and folder names that you want to be included in your published npm package.
      You can exclude things like tests and source code simply by not including those folders in this array.
      Npm will also exclude anything that is in your <code class="language-text">.gitignore</code> file.
      And, you don't have to, but you can also create a <code class="language-text">.npmignore</code> file, which it will also ignore things from.
      It's worth noting that there are a few things that npm will always publish, and you cannot ignore, such as your <code class="language-text">package.json</code> file, and a few things that it will never publish, such as your <code class="language-text">node_modules</code> folder.
      If you leave the files array undefined or empty, then npm will include everthing that is not otherwise ignored.
      I find it easiest to use the files array, though, and specify only what I want npm to publish.
      This is the meat and potatos of creating your package, so it's worth checking out the docs.
      <ul>
        <li><a href="https://docs.npmjs.com/files/package.json#files" target="_blank">files docs</a></li>
        <li><a href="https://docs.npmjs.com/cli/publish" target="_blank">npm-publish docs</a></li>
      </ul>
    </p>

    <p>
      Please keep in mind that this array has no effect on your source code repository, so everything will still be stored on github (or wherever your source code lives), it just won't be published as part of your npm package.
    </p>

    <p>
      So, after all that explaining, here is a snippet from the package.json file from my lernato-common project.
      <pre><code class="language-javascript">
        "name": "@lernato/common",
        "version": "1.0.0",
        "main": "dist/index.js",
        "types": "dist/index.d.ts",
        "files": [
          "dist/",
          "package.json",
          "README.md",
          "LICENSE"
        ],
        ...
      </code></pre>
      So, when you <code class="language-bash">npm install @lernato/common</code>, you only get what is in the files array in your node_modules folder.
      And when you <code class="language-javascript">import * from '@lernato/common'</code> in your project, you get whatever is exported through the dist/index.js file.
    </p>

    <h3>Package Naming</h3>

    <p>
      I also want to quickly touch on package naming.
      You might wonder how to group your packages under a given package scope, like I have done with <code class="language-text">@lernato/common</code>.
      If you have a private repo in Verdaccio, that will happen automatically based on the <code class="language-text">name</code> field in your <code class="language-text">package.json</code> file.
      But, if you want this to work on the public npm repo, then you first have to create an organization for your scope on npmjs.com.
      For example, I had to create an organization named <em>lernato</em> in order for npmjs.com to respect the @lernato scope in my packages.
    </p>

    <h2>package.json scripts</h2>

    <p>
      All of this building and versioning and publishing can lead to a lot of command typing if we let it.
      Fortunately, npm gives us a way to automate most of this work with scripts.
      The following is a snippet from how I like to set up my <code class="language-bash">package.json</code> scripts to handle my package build and deployment process.

      <pre><code class="language-json">
        "scripts": [
          "prebuild": "npm test && rimraf dist/"
          "build": "node ./build.js",
          "prepush": "npm run build",
          "push": "npm publish --registry http://localhost:4873",
          "push:major": "npm run version:major && npm run push",
          "push:minor": "npm run version:minor && npm run push",
          "push:patch": "npm run version:patch && npm run push",
          "version:major": "npm version major --no-git-tag-version",
          "version:minor": "npm version minor --no-git-tag-version",
          "version:patch": "npm version patch --no-git-tag-version",
        ]
      </code></pre>

      Then, whenever I want to push a patch to my package I just run:
      <pre><code class="language-bash">
        npm run push:patch
      </code></pre>
      and my package is tested, built, versioned, and published - all with one command.

    </p>

  </div>
</div>
