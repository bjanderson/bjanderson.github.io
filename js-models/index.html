<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>JavaScript Models | BJ Anderson</title>

  <meta name="description" content="Practical advice for developing websites and web applications.">
  <meta name="author" content="BJ Anderson">

  <!-- How to generate favicons with GIMP - http://thenewcode.com/467/Creating-Multi-Resolution-Favicons-For-Web-Pages-With-GIMP -->
  <link rel="icon" href="/favicon.ico?v=0">
  <!-- <link rel="apple-touch-icon" sizes="57x57" href="/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff"> -->

  <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Pacifico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Permanent+Marker"> -->

  <link rel="stylesheet" href="/vendor/prism/prism.css">

  <link rel="stylesheet" href="/styles.css">

  <script>
    function toggleActive() {
      try {
        document.querySelector('.navbar-burger').classList.toggle('is-active');
        document.querySelector('.navbar-menu').classList.toggle('is-active');
      } catch (err) {
        console.error('Error in toggleActive');
      }
    }
  </script>

</head>
<body>

  <nav class="navbar" role="navigation" aria-label="main navigation">

    <div class="navbar-brand">

      <a class="navbar-item" href="/">
        <div class="logo-image">
          <img src="/logo/emoji-64.png" alt="Logo">
        </div>
        <span class="title"> BJ Anderson </span>
      </a>

      <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="headerNavBar" onclick="toggleActive()">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="headerNavBar" class="navbar-menu">

      <div class="navbar-start">
        <!-- <a class="navbar-item"> Blog </a> -->
      </div>

      <div class="navbar-end">
        <a class="navbar-item" href="/about.html"> About </a>
      </div>

    </div>
  </nav>

  <section class="section main">
    <div class="container">
      <div name="pwd-poll"></div>
      <div class="blog-post">

  <div class="blog-post-image">
    <img src="./blog-post-image.jpg" alt="Blog Post Image">
    <div class="attribution">
      <a target="_blank"
        href="https://www.behance.net/TomaszBolek">
        Tomasz Artur Bolek | Behance.net
      </a>
    </div>
  </div>

  <div class="content">
    <h1>JavaScript Models</h1>

    <p>
      Models are data structures that we use to define the shape of our data.
      You might also know them as objects, as in Object Oriented Programming, but in JavaScript everything is an Object, so it's not clear that we are talking about something specific if we just call them Objects.
    </p>

    <p>
      The usefulness of the term "model" can be exemplified in it's use in the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank">Model-View-Controller</a> (MVC) architecture.
      The model is the part of the software that holds the data that is to be manipulated by the controller, and displayed by the view.
      There are several other Model-View variants, collectively referred to as MV*.
      The core component of all of them is the model.
      I'm not strictly holding the models I am talking about here to the standards of those various architectures, but I want to point out that the "model" data structure has been a useful part of web architecture for a long time.
    </p>

    <p>
      The model is the core component of the user interface.
      It is the one place where you can filter and manage all of the data that passes through your application.
      You can do all of your data validation in the model.
      And you can set the properties in your models to have reasonable defaults so that you can minimize the amount of null checking and defensive code you will need to write throughout your application, and also prevent showing strange values like null, NaN, undefined, etc... to your users.
    </p>

    <div class="centered-image mv1">
      <img src="./js-models-1.png" alt="JS Models Diagram">
    </div>

    <p>
      Of course, once you begin using models as the fundamental data structure in your code, you will begin to see how useful it is to move beyond simply defining properties on the model, and start adding functions to your models that increase the convenience of using them everywhere.
      Just remember to keep the application logic isolated from the model itself.
      Any functions that the model carries with it should specifically serve the purpose of reading from or writing to the model's properties.
    </p>

    <p>
      Some useful functions for a model would be:
      <ul>
        <li>validation - to validate the data being assigned to each field in the model</li>
        <li>comparison - to easily check if two models are equal to each other</li>
        <li>formatting - to format certain pieces of the data for the UI (e.g. date, address, full name, etc...)</li>
      </ul>
    </p>

    <p>
      Some things we should not do in models are:
      <ul>
        <li>call the server</li>
        <li>control or manipulate the user interface</li>
        <li>implement logic that requires knowledge of anything that is not part of the model</li>
      </ul>
    </p>

    <h2>A Model</h2>
    <p>
      So what might a model look like?
      Let's make a Person model as an example.
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        constructor(obj) {
          obj = obj != null ? obj : {}
          this.address = obj.address != null ? obj.address : ''
          this.birthDate = obj.birthDate != null ? obj.birthDate : ''
          this.firstName = obj.firstName != null ? obj.firstName : ''
          this.friends = obj.friends != null ? obj.friends : []
          this.lastName = obj.lastName != null ? obj.lastName : ''
          this.petNames = obj.petNames != null ? obj.petNames : []
        }
      }
    </code></pre>

    <p>
      This simple model has six properties (address, birthDate, firstName, friends, lastName, and petNames).
      The constructor takes in an optional object as its only parameter.
      <ul>
        <li>If the obj is undefined or null then each model property is set to its respective default value.</li>
        <li>If the obj is defined but a specific property on that obj is undefined or null then that respective model property is set to the default value.</li>
        <li>If the obj is defined and the property on that obj is defined then that respective model property is set to the property from the obj.</li>
      </ul>
    </p>

    <p class="note">
      In JavaScript
      <code class="language-javascript">something == null</code>
      (double equals) returns true if something is null or undefined, whereas
      <code class="language-javascript">something === null</code>
      (triple equals) only returns true if something is null.
    </p>

    <p class="note">
      We could set a default value for the obj when we define it as a parameter to the constructor
      <br><br>
      <code class="language-javascript">constructor(obj = {}) { ... }</code>
      <br><br>
      but <code class="language-javascript">null</code> counts as a value, so if we ever pass
      <code class="language-javascript">null</code> into the constructor, all of the calls to
      <code class="language-javascript">obj.property</code> will fail.
      The end result is that we would still have to check if
      <code class="language-javascript">obj === null</code>.
    </p>

    <p class="note">
      You may wonder why I'm not doing truthy comparisons
      (<code class="language-javascript">obj == null</code>
      instead of <code class="language-javascript">obj != null</code>).
      Writing the conditionals this way allows us to put the default values on the outer right edge of the assignment statements, which makes them much easier to find when reading through the code to find out what the default value for a given property is.
    </p>

    <h2>Input Validation</h2>

    <p>
      If we wanted to validate the input, we could create a function to do that and make that part of the assignment conditional like so:
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        constructor(obj) {
          ...
          this.birthDate = this.isValidDate(obj.birthDate) ? obj.birthDate : ''
          ...
        }

        isValidDate(date) {
          let isValid = true

          try {
            let d = new Date(date)
            isValid = d.toString() !== 'Invalid Date'
          } catch (err) {
            console.error('Person.isValidDate - Invalid Date: ', date)
            isValid = false
          }

          return isValid
        }
      }
    </code></pre>

    <p>
      That way, if the input value is valid it is set on the model, otherwise the model property is set to the default value.
    </p>

    <p>
      Notice that our try/catch in the isValidDate function does not throw an error.
      It allows a value to be returned from the function even if the input was invalid, but still alerts us to the fact that we saw data that we were not expecting.
      If you want to stop the app because of this, for instance, if not having a date defined in this model is a deal breaker for your app, then throw an error instead of just logging an error.
    </p>

    <p class="note">
      <em>JavaScript Date Defaults</em><br><br>
      Setting a reasonable default value for dates can be tricky, and picking the right one may vary from application to application.
      If you create a new date with an empty string (or NaN), e.g. <code class="language-javascript">x = new Date('')</code>, then x.toString() will return "Invalid Date", and functions like x.getMonth() will return NaN.
      If you create it with no given input, it will create a date representing the time that the Date was instantiated.
      If you create it with 0 or null, it will create a date of Jan 1, 1970.
      And giving it a negative number will just count backwards from Jan 1, 1970.
      <br><br>
      Dates are generally one of the most difficult things to deal with consistently in all cases.
      We have to take into account things like different time-zones, different possible input formats, different default formats for different locales, etc...
      Dates are the one piece of data where using a 3rd party library to deal with them is easily justified.
      <br><br>
      One way to ensure that everyone knows exactly what the date should be is to represent it as the number of milliseconds.
      That way there is no guessing if it is formatted as mmddyyyy, ddmmyyyy, mmddyy, etc...
      If the date truly is unspecified, the best default value is an empty string - at least that will let your code know that it received something that should not be interpreted as a date, and it can safely be displayed in the UI.
    </p>

    <h2>Data Formatting</h2>
    <p>
      Now let's consider when we want to compile some, or all, of the model data into things that we can easily use in the UI.
      For example, we probably want to format the birthDate consistently everywhere we show it.
      Instead of writing code to do that formatting everywhere that we want to see it in the UI, we should create a function on the model to do that formatting.
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        ...
        formatDate(date) {
          let formattedDate = ''

          try {
            formattedDate = new Date(date).toLocaleDateString()
          } catch (err) {
            console.error('Person.formatDate - Invalid date: ', date)
          }

          return formattedDate
        }
      }
    </code></pre>

    <p>
      Now, in the rest of our code, we <em>could</em> call this function every time we want to display the person's birth date.
      I say <em>could</em> because we can potentially make this better by adding a property called something like formattedBirthDate to our Person model, and then only calling this function once when the Person is instantiated.
      Then we can just use person.formattedBirthDate throughout our code.
    </p>

    <p>
      So our constructor would look like this:
    </p>

    <pre><code class="language-javascript">
      class Person {
        constructor(obj) {
          ...
          this.birthDate = this.isValidDate(obj.birthDate) ? obj.birthDate : ''
          this.formattedBirthDate = this.formatDate(this.birthDate)
          ...
        }
      }
    </code></pre>

    <p>
      Likewise, if we want to show the person's full name in the UI, we can create a function to get the fullName instead of writing that code everywhere that we want to use it in the UI.
    </p>

    <pre><code class="language-javascript" data-start="3">
      class Person {
        ...

        getFullName() {
          return `${this.firstName} ${this.lastName}`
        }
      }
    </code></pre>

    <p class="note">
      If you are trying to optimize your code, then your models could help you conveniently manage a lot of those optimizations.
      <br><br>
      Adding properties to the model will cost you memory, but reduce your CPU usage since you won't be calling functions to get the same value over and over.
      On the other hand, using functions will cost you CPU usage, but won't saturate your memory space with different variations of the same data.
      <br><br>
      The best optimization strategies will often use a mix of both.
      For example, formatting dates can be very CPU expensive relative to the amount of memory it would cost to store the formatted date string.
      On the other hand, storing a person's full name might cost more in terms of memory than it would in CPU usage to concatenate a couple of strings.
      <br><br>
      And it should go without saying that if the formatting function could potentially return different values every time it is called (such as containing time stamps, or counts, etc...) then you should not set it as a property on the model, but call the function throughout the rest of your code instead.
    </p>

    <h2>Models Composed Of Models</h2>

    <p>
      It is quite common to have models that are composed of other models.
      It would be great if every model was composed only of primitives (number, string, etc...), but that is rarely the case in the real world.
    </p>

    <p>
      Let's take our person.address field for example.
      Chances are that this field won't be a string, but it will be an object containing various data about the address.
    </p>

    <pre><code class="language-javascript line-numbers">
      class Address {
        constructor(obj) {
          obj = obj != null ? obj : {}
          this.city = obj.city != null ? obj.city : ''
          this.state = obj.state != null ? obj.state : ''
          this.street = obj.street != null ? obj.street : ''
          this.zipCode = obj.zipCode != null ? obj.zipCode : ''
          this.fullAddress = this.getFullAddress()
        }

        getFullAddress() {
          return `${this.street} ${this.city} ${this.state} ${this.zipCode}`
        }
      }
    </code></pre>

    <p>
      And our Person constructor will now look like this:
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        constructor(obj) {
          obj = obj != null ? obj : {}
          this.address = new Address(obj.address)
          ...
        }
      }
    </code></pre>

    <p>
      Notice that we do not need to null check the obj.address property in our Person model because the constructor for our Address model already has that null check built in to it.
      We can simply trust our Address model to give us something useful no matter what we create it with.
      And this should be true of all of our models!
      If we build them to be trustworthy for our code, then we only have to focus on using them correctly throughout our code.
    </p>

    <h2>Models With Arrays</h2>

    <p>
      You are inevitably going to have models that contain arrays.
      Sometimes they will be arrays of primitive values, and sometimes they will be arrays of other models.
    </p>

    <p>
      In the case that your model has an array of primitive values - let's use strings as an example - then you can either trust the input to be all strings, or loop over the array and type-check each value.
      If you opt for type-checking then you should only add things that either are strings or that can be converted to strings (e.g. things that do not return [object Object] from .toString()).
      If you trust the input, then assigning the array to your model looks the same as assigning a primitive value to your model:
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        constructor(obj) {
          ...
          this.petNames = obj.petNames != null ? obj.petNames : []
          ...
        }
      }
    </code></pre>

    <p>
      One of the difficulties of setting arrays, can be in using APIs that don't always return an array when you expect them to.
      I've worked with APIs that would return null instead of an empty array, a single object instead of an array with one object in it, and an actual array only if there was more than one object to put in the array.
      Detecting if a value is null and setting it to an empty array in the model is easy enough.
      But what about detecting if, when it's not null, you received an object or an array?
    </p>

    <p>
      Enter the getArray function:
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        ...

        getArray(objs) {
          objs = objs != null ? objs : []
          let array = []

          if (objs.constructor === Array) {
            array = objs
          } else {
            array = [objs]
          }

          return array
        }
      }
    </code></pre>

    <p>
      Now our assignment in the constructor would look like this:
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        constructor(obj) {
          ...
          this.petNames = this.getArray(obj.petNames)
          ...
        }
      }
    </code></pre>

    <p>
      Now we can rest assured that our calls to person.petNames.length, person.petNames.map, person.petNames.find, etc... won't crash our UI.
    </p>

    <p>
      And finally, how do we handle arrays of other models?
      If I get an array of models as input, I want to run all of those models through their respective constructors in order to make sure that they are all safe to use in my UI.
      But what if I have several arrays, each one with a different type of model?
    </p>

    <p>
      Well, we can build a function to help us with that.
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        ...

        getArrayOfModels(clazz, objs) {
          objs = this.getArray(objs)
          const models = []

          for (const obj of objs) {
            models.push(new clazz(obj))
          }

          return models
        }
      }
    </code></pre>

    <p>
      Notice that we are taking in a parameter named clazz that is the constructor for the type of model that will be in this array.
      We can call <code class="language-javascript">new clazz(obj)</code> to create a new instance of whatever model we passed in to the function.
    </p>

    <p>
      Also notice that we are making sure that the input objs is actually an array by resetting it with our getArray function.
    </p>

    <p>
      You might also want to check if each object is actually an instance of the model you are creating so that you don't add a bunch of default instances of the model - say, if there are a lot of nulls in the array of objs.
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        ...

        getArrayOfModels(clazz, objs) {
          objs = this.getArray(objs)
          const arr = []

          for (const obj of objs) {
            if (this.hasPropertyOf(clazz, obj)) {
              arr.push(new clazz(obj))
            }
          }

          return arr
        }

        hasPropertyOf(clazz, obj) {
          const model = new clazz()
          const modelKeys = Object.keys(model)

          for (const key of modelKeys) {
            if(obj.hasOwnProperty(key)) {
              return true
            }
          }

          return false
        }
      }
    </code></pre>

    <p>
      I'm using a loose definition of "if an object is an instance of a model" by only requiring an object to have at least one field in common with the model.
      Basically, if the object has <em>any</em> information that the model can use, I want to use it.
      You might require the object to have <em>all</em> properties of the model in order for it to be useful for you.
      In that case you can just make a slight change to the implementation of the hasPropertyOf function (return false if hasOwnProperty returns false, otherwise return true) and call it something like isInstanceOf.
    </p>

    <p>
      Now, let's say that the person.friends property, which we see has a default value of [], is an array of People models.
      We would set that property in our constructor like this:
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        constructor(obj) {
          ...
          this.friends = this.getArrayOfModels(Person, obj.friends)
          ...
        }
      }
    </code></pre>

    <!--
    <h2>Default Values</h2>

    <p>
      In this model we are using a ternary if statement to determine if a value exists for each respective field, or if a default value needs to be assigned.
      If you trust your inputs, then this is fine, but what if you expect person.firstName to be a string, but it was actually given an array, or an object, etc...
    </p>

    <p>
      We can address this case by creating a function that will ensure that we are setting a string no matter what input we are given.
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        ...

        getString(value) {
          let str = ''

          if (typeof value === 'string') {
            str = value
          } else {
            try {
              value = value.toString();
              if (value !== '[object Object]') {
                str = value
              }
            } catch (err) {}
          }

          return str
        }
      }
    </code></pre>

    <p>
      Now we can use this function to make sure that any field that we expect to be set to a string, is set to a string, no matter what input we give it.
      For the sake of brevity, let's assume that we also have functions for getDate and getArray.
      Then our person constructor would look like this:
    </p>

    <pre><code class="language-javascript line-numbers">
      class Person {
        constructor(obj) {
          obj = obj != null ? obj : {}
          this.address = getString(obj.address)
          this.birthDate = getDate(obj.birthDate)
          this.firstName = getString(obj.firstName)
          this.friends = getArray(obj.friends)
          this.lastName = getString(obj.lastName)
          this.petNames = getArray(obj.petNames)
        }
      }
    </code></pre>
    -->

    <h2>Model Utils</h2>

    <p class="note">
      <em>utility</em>
      <br>
      - a program or routine designed to perform or facilitate especially routine operations on a computer
    </p>

    <p>
      Inevitably, our models are going to have things in common, like needing to validate and format dates and other inputs, and needing to set arrays of other models.
      So let's look now at building a common place to put these functions  - utils.
    </p>

    <p>
      We could pull all of our reusable methods out into a single file, like this:
    </p>

    <p class="note">
      You can see that I am declaring all of my util methods as static because there is no need to create an instance of a utils class just to use these methods.
      Each function relies only on its inputs.
    </p>

    <pre><code class="language-javascript line-numbers">
      class ModelUtils {

        static formatDate(date) {
          let formattedDate = ''

          try {
            formattedDate = new Date(date).toLocaleDateString()
          } catch (err) {
            console.error('ModelUtils.formatDate - Invalid date: ', date)
          }

          return formattedDate
        }

        static getArray(objs) {
          objs = objs != null ? objs : []
          let array = []

          if (objs.constructor === Array) {
            array = objs
          } else {
            array = [objs]
          }

          return array
        }

        static getArrayOfModels(clazz, objs) {
          objs = ArrayUtils.getArray(objs)
          const array = []

          for (const obj of objs) {
            if (ModelUtils.hasPropertyOf(clazz, obj)) {
              array.push(new clazz(obj))
            }
          }

          return array
        }

        static hasPropertyOf(clazz, obj) {
          const model = new clazz()
          const modelKeys = Object.keys(model)

          for (const key of modelKeys) {
            if(obj.hasOwnProperty(key)) {
              return true
            }
          }

          return false
        }

        static isValidDate(date) {
          let isValid = true

          try {
            let d = new Date(date)
            isValid = d.toString() !== 'Invalid Date'
          } catch (err) {
            console.error('ModelUtils.isValidDate - Invalid Date: ', date)
            isValid = false
          }

          return isValid
        }
      }
    </code></pre>

    <p>
      But, as time goes on, the number of methods in this file could become quite large.
      So, we could take this one step further and define several different utility files, and let each one focus on one particular type of data.
      Like this:
    </p>

    <pre><code class="language-javascript line-numbers">
      class ArrayUtils {
        static getArray(objs) { ... }

        static getArrayOfModels(clazz, objs) { ... }
      }
    </code></pre>

    <pre><code class="language-javascript line-numbers">
      class DateUtils {
        static formatDate(date) { ... }

        static isValidDate(date) { ... }
      }
    </code></pre>

    <pre><code class="language-javascript line-numbers">
      class ModelUtils {
        static hasPropertyOf(clazz, obj) { ... }

        static isInstanceOf(clazz, obj) { ... }
      }
    </code></pre>

    <p>
      And finally, we don't have to, but we could bundle these different utility files under one main utility file - like this:
    </p>

    <pre><code class="language-javascript line-numbers">
      class Utils {
        static get array() { return ArrayUtils }
        static get date() { return DateUtils }
        static get model() { return ModelUtils }
      }
    </code></pre>

    <p>
      Then we could just import the Utils class wherever we need it and use it like this:
    </p>

    <pre><code class="language-javascript">
      Utils.array.getArrayOfModels(Person, obj.friends)
    </code></pre>

    <h3>Update</h3>

    <p>
      I created an <a href="https://www.npmjs.com/package/@lernato/common" target="_blank">npm package</a> with all of the model utilities that I commonly use. You can install it by running:
    </p>

    <pre><code class="language-bash">
      npm i -S @lernato/common
    </code></pre>

    <p>
      And then, using these utilities, our Person model would look this:
    </p>

    <pre><code class="language-javascript line-numbers">
      import {
        getArrayOfModels,
        getObject,
        getString,
        getValueOrDefault
      } from '@lernato/common';

      class Person {
        constructor(obj) {
          obj = getObject(obj);
          this.address = new Address(obj.address)
          this.birthDate = getValueOrDefault(obj.birthDate, '')
          this.firstName = getString(obj.firstName)
          this.friends = getArrayOfModels(Person, obj.friends)
          this.lastName = getString(obj.lastName)
          this.petNames = getArrayOfStrings(obj.petNames)
        }
      }
    </code></pre>

    <p>
      The source code for these utilities is available on <a href="https://github.com/bjanderson/lernato-common/tree/master" target="_blank">Github</a>.
      <!-- And the <a href="https://bjanderson.github.io/lernato/common/index.html" target="_blank">documentation</a> for them is too! -->
    </p>

    <h2>Model Testing</h2>

    <p>
      Writing unit tests for models is pretty straight forward, and mostly repetitive from model to model.
      That being said, if any part of your code should have 100% test coverage, it is your models.
      The more dependable your models are, and the more you depend on them, the more reliable the rest of your code will be as a result.
    </p>

    <p>
      The main things you will want to test your models for are these:
    </p>

    <ul>
      <li>does an instance of the model have all of the properties you expect it to, and only those properties</li>
      <li>does the model assign all input values correctly
        <ul>
          <li>assign only valid properties from the input object to the corresponding model properties</li>
          <li>assign default values for any invalid or undefined inputs</li>
          <li>create new instances of other models when it should</li>
          <li>not create new instances of other models when it should not (see hasPropertyOf above)</li>
          <li>create arrays correctly (even if the input is not an array)</li>
          <li>assign formatted data as expected (e.g. formattedBirthDate)</li>
        </ul>
      </li>
      <li>does the model set all the defaults correctly when the input is:
        <ul>
          <li>undefined</li>
          <li>null</li>
          <li>an empty object, or an object that does not contain any of the model's properties</li>
        </ul>
      </li>
      <li>do the model's functions work correctly
        <ul>
          <li>return expected values</li>
          <li>modify the model's state as expected</li>
          <li>log errors when expected</li>
          <li>throw errors when expected</li>
        </ul>
      </li>
    </ul>

    <p>
      Think about it.
      If you could trust your models to have valid data at any point in your application:
    </p>
    <ul>
      <li>How much easier would it be for you to write and maintain your code?</li>
      <li>How much faster would you be able to find and fix bugs?</li>
      <li>How much cleaner would your code be?</li>
    </ul>

    <h2>Data Cleanup</h2>

    <p>
      One final point that I want to cover while we're on this topic is the cascading effect that happens when we compose models of other models.
    </p>

    <p>
      If I receive a JSON object from the server that represents a person, and the person uses the Address model for it's address field, then I just have to pass the JSON object to the person constructor, and the person constructor will pass the corresponding address part of that object to the Address constructor.
      When this happens with complex models (composed of models that are composed of other models), it's almost magical to see how a complex, dirty JSON object can get cleaned up into something that won't break the UI, just by passing it to a model constructor.
    </p>

    <p>We could use the Person model, for example, like this:</p>

    <pre><code class="language-javascript">
      let person = new Person(server_response_json)
      let fullAddress = person.address.fullAddress
    </code></pre>

    <p>
      And be confident that person is defined, person.address is defined, and person.address.fullAddress is at least an empty string.
      How many null checks and how much display formatting code has this just removed from your application?
    </p>

    <h2>Conclusion</h2>

    <p>
      Models give us the ability to handle data that may or may not be suitable for our application, format that data to suit our various uses, and set default values that we can be confident will not break our application or confuse our users.
      And they allow us to minimize the amount of defensive code we need to write throughout our application for dealing with the otherwise unpredictable state of the data we are using, which means our code is leaner, cleaner, more maintainable, and easier to test.
    </p>

    <p>
      Building applications using models is like building a house out of bricks.
      Each model is a solid, well-defined piece of the structure.
      If you are not using well-defined models in your code, how often do you have to wonder if the data you are working with is actually in a valid state for the code you are using it in?
      And how often do you get bug reports of things not working, only to find out that the error was caused by something being undefined, or null, or not being an array when it should have been?
    </p>

    <p>
      The model architecture pattern is not to be thought of as something that you plan to implement sometime in the future.
      As demonstrated by the existence of many MV* architecture patterns, it is a default state of mind when approaching the development of any JavaScript application.
      If your project does not currently use this pattern, I highly recommend making the investment to shift it over.
      And certainly, for any projects you start in the future, no matter what they are, models should be among the first code you write.
    </p>

    <!-- <h2>Examples</h2> -->

    <!-- <p>
      The code used in this article is available, fully built out and tested, on <a href="https://github.com/bjanderson/practicalwebdev-examples/tree/master/js-models" target="_blank">Github</a>.
    </p> -->

    <!--
    <h2>Practice</h2>

    <p>
      1. Given the following JSON object, create a model or models that represent the data and set reasonable defaults for each field.
    </p>

    <p>
      2. Given the following requirements, add functions to each model, as required, to allow the model to help meet the requirements.
    </p>

    <p>
      3. Write unit tests for the following model.
      Make sure that the model is setting given data correctly, as well as setting default values when it should.
      Also make sure that the functions work for any values that the model fields might be set to.
    </p>
    -->
  </div>
</div>

    </div>
  </section>

  <footer class="footer">
    <div class="col left">

    </div>

    <div class="col middle">
      <div>
        <a href="/">bjanderson.github.io</a>
      </div>

      <div>
        &copy; 2019 BJ Anderson.
      </div>
    </div>

    <div class="col right">

    </div>
  </footer>

  <script src="/vendor/prism/prism.js"></script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112306194-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-112306194-1');
  </script>

</body>
</html>
